#version 430

#include "constantbuffers.glsl"
#include "landscapeRenderData.glsl"
#include "landscapeRenderFunctions.glsl"

layout(location = 0) in ContInVertex In[];
layout(location = 2) in int UnderTerrain[];
layout(location = 0) out EvalInVertex Out[];

// Output quads
layout(vertices = 3) out;

void main()
{
	// Per Patch computation.
	if (gl_InvocationID == 0)
	{	
		// completly under terrain?
		if(UnderTerrain[0] == 1 && UnderTerrain[1] == 1 && UnderTerrain[2] == 1)
		{
			gl_TessLevelOuter[0] = gl_TessLevelOuter[1] = gl_TessLevelOuter[2] = -1.0f;
			gl_TessLevelInner[0] = -1.0f;
		}
		else
		{
			vec3 mid = 0.25f * (In[0].WorldPos + In[1].WorldPos + In[2].WorldPos);

			for(int i=0; i<3; ++i)	// unroll in ogl 4.3?
			{
				int second = (i+1) % 3;
				gl_TessLevelOuter[(i+2)%3] = clamp(EstimateSphereSizeAroundEdge(In[i].WorldPos, In[second].WorldPos) * TrianglesPerClipSpaceUnit, 1.0f, MaxTesselationFactor);
			}

			gl_TessLevelInner[0] = (gl_TessLevelOuter[0] + gl_TessLevelOuter[1] + gl_TessLevelOuter[2]) * 0.25f; 
			

			// Debug: No Tess
			//gl_TessLevelOuter[0] = gl_TessLevelOuter[1] = gl_TessLevelOuter[2] = 1.0f;
			//gl_TessLevelInner[0] = 1.0f;
		}
  	}

    Out[gl_InvocationID].WorldPos2D = In[gl_InvocationID].WorldPos.xz;
    Out[gl_InvocationID].HeightmapCoord = In[gl_InvocationID].HeightmapCoord;
}